* Ch1 - Building Abstractions with Procedures
** Interpretor Evaluation of Combinations
   1. Evaluate the subexpressions of the combination
   2. Apply the procedure that is the value of the leftmost subexpression (the operator)
       to the arguments that are the values of the other subexpressions (the operands)
** Substitution Model
    A model to determine the "meaning" of procedure application.

    To apply a compound procedure to arguments, evaluate the
    body of the procedure with each formal parameter replaced
    by the corresponding argument.

    For procedure applications that can be modeled using substitution and that yield
    legitimate vlaues, normal-order and applicative order evaluation produce
    the same value.

*** Normal-order evaluation
    Fully expand operand expressions for parameters until an expression of only
    primitive opperators then reduce for evaluation.
    "Fully expand and then reduce"

*** Applicative-order evaluation
    Method the interpreter actually uses.
    "Evaluate the arguments and then apply"


    
      
    
   
   
    

** Procedures as Black-Box Abstraction
   - procedural abtraction :: 
        An abstration of a procedure (i.e square function). At this level
        of abstraction, any procedure that computes the square is
        equally good
   - bound variable :: the name of the formal parameter of a procedure 
                       doesn't matter (i.e local scope). We say the 
                       procedure definition 'binds' its formal 
                       parameters.
                       Caveat: 
                       The meaning of a procedure definition
                       is unchanged if a bound variable is consistently 
                       renamed throughout the definition.
   - free variable :: an unbound variable.
   - scope :: The set of expressions for which a binding defines a name
              is called the scope of that name. In a procedure definition,
              the bound variable declared as the formal parameters of 
              the procedure have the body of the procedure as their scope.
   
   We can have nested 'define' in a procedure to make those internal
   definitions be scoped local to the outer procedure.

   - block structure :: nesting of definitions
   - lexical scoping :: dictates that free variables in a procedure are
        taken to refer to the bindings made by enclosing procedure
        definitions; that is, they are looked up in the environment
        in which the procedure was defined.
                       
        
